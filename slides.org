#+title: Freenet for Journalists\\ \vspace{0.5cm} \scriptsize The technical part of the solution for freedom of the press in the internet
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: default
#+options: H:2
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_envargs(Env Args) %4BEAMER_col(Col) %8BEAMER_extra(Extra)
#+PROPERTY: BEAMER_col_ALL 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.0 :ETC

* Why?

** Why Freenet?

#+BEGIN_QUOTE
I worry about my child and the Internet all the time, even though she' too young to have logged on yet. Here's what I worry about. I worry that 10 or 15 years from now, she will come to me and say 'Daddy, where were you when they took freedom of the press away from the Internet?'
--Mike Godwin, Electronic Frontier Foundation, [[https://w2.eff.org/Misc/EFF/quotes.eff.txt][“Fear of Freedom” (1995)]]
#+END_QUOTE

** Why now?

#+BEGIN_QUOTE
“There is now no shield from forced exposure…The foundation of Groklaw is over…the Internet is over” --Groklaw, [[http://www.groklaw.net/article.php?story=20130818120421175][Forced Exposure (2013-08-20)]]
#+END_QUOTE

* About
** What is Freenet?

#+BEGIN_QUOTE
Freenet is the technical part of the solution for freedom of the press in the internet.
#+END_QUOTE

** THE technical part? Other projects
***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
****                                                                  :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :END:


***** Pure Transport                                     :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. tor, i2p/

- No offline hosting
- vulnerable to DoS
- correlation attacks

#+latex: \small
/this killed the Black Goblin Market/

***** Hosting with cost                                             :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. TAHOE-LAFS, MaidSafe/

- Fixed storage: When it is full, it is full
- DoS-resistance? Spam-resistance? Cost?

Good content often comes from small publishers.

****                                                                  :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :END:

***** Pure messaging                                                :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. bitmessage, invisible.im/

- No publishing
- No offline hosting

***** Server-based                                                  :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. SecureDrop/

- Requires powerful infrastructure 
- DoS-able
- Timing attacks (correlation)

***** GNUnet?                                                       :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

Good, but more filesharing than publishing.

** THE technical part? Freenet

***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
**** Communication                                            :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *persistent pseudonyms*
- *spam resistance* via WoT
- *multiple applications* (Sone, FMS, Freemail, FlogHelper, ...)

**** Publishing                                               :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *offline hosting* \\ Join, drop content, leave.
- *decaying storage* \\ lifetime depends on user demand

***                                                                 :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:

Proven track record of providing censorship resistant publishing and communication since 2000.

** The TECHNICAL part?
***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
**** Tech alone is not enough                                 :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

Complete blocking and surveillance is possible.

**** Politics alone is not enough                             :B_block:BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :BEAMER_env: block
     :END:

If surveillance and censorship is trivial, it will be done.

*** Tech and Politics                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:

Privacy technology provides the background on which politics can work: Making surveillance and censorship expensive and hard enough that we can win the political battle.


** Who are we?

***                                                           :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.6
    :END:

- 2 paid part time developers: \\ toad and xor.
- About a dozen free-time developers.
- Some anonymous contributors.
- Communication mostly over IRC (=#freenet @ irc.freenode.net=) and FMS
  (in Freenet).

***                                                           :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.35
    :END:

#+caption: Some Freenet developers at CTS4. From left to right: ArneBab, toad, leuchtkaefer and digger3.
[[file:freenet-cts4-20130930_135137.jpg]]


* Tech

** About the tech
***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
**** Datastore                                                :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *decentralized* \\ on the computers of users
- *encrypted chunks of files* \\ key (URL) to assemble, decrypt and identify
- *anonymous pseudonyms* \\ public/private key publishing

**** Routing                                                  :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *small world*: scale free
- *optional friend-to-friend* (Darknet)
- *location*: [0..1) for each file chunk and node
- *find route*: from node to file chunk
- *forward data*: travels along the route

*** Applications                                                    :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:

- *subscribe to keys*: 30s to 30 min round trip time.
- *base for applications*: Websites, Forums, Microblogging, Chat.
- *spam resistance*: Web of Trust (2 implementations).

** Routing

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.62
    :END:

#+caption: Finding the route to a chunk of data.
[[./freenet-routing.png]]

** Network structure

*** Opennet                                                   :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.45
    :END:

- *Optimize peer-connections* \\ via success-metric
- *Distance Constraint* \\ maximum number of long connections

*** Darknet (friend-to-friend)                                :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.45
    :END:

- *Assume small world* \\ connections to people known in real life
- *Reconstruct* \\ the structure by swapping locations

** Measured Network Structure

#+caption: Link length distribution in Freenet. The green line would be an ideal network. Blue would be a random network. Red is the measured distribution. Randomization from local requests, churn and inhomogenity in the network skew the distribution.
[[./607-plot_link_length.png]]


** Routing Simulation: Random Routing

#+BEGIN_SRC python :tangle randomroute.py :exports results :results output
  import numpy
  import pylab
  import math
  import matplotlib.cm
  size = 1000
  locs = numpy.random.random(size)
  outdegree = int(math.log(size, 2))
  def plotring(locs, paths, title):
    pylab.clf()
    ringx = numpy.sin(locs*math.pi*2)
    ringy = numpy.cos(locs*math.pi*2)
    pylab.scatter(ringx, ringy)# , color=matplotlib.cm.spectral(locs))
    for path in paths:
        path = numpy.array(path)
        pathx = numpy.sin(path*math.pi*2)
        pathy = numpy.cos(path*math.pi*2)
        for n,x in enumerate(pathx):
          try:
            xp1 = pathx[n+1]
            y = pathy[n]
            yp1 = pathy[n+1]
            # color = matplotlib.cm.spectral(locs[n])
          except:
            break
          # pylab.plot([x, xp1], [y, yp1])# , color=color)
        pylab.plot(pathx, pathy)# , color=color)
    pylab.show()

  def step(path, node, peers, target):
    # depth first traversal
    p = set(path)
    untested = [peer for peer in list(peers)
                if not peer in p]
    if not untested:
      if not path[:-1]:
         raise ValueError("No nodes to test and cannot step back: Cannot find a route to the target in this network.")
      # step back
      return path[-2]
    best = sorted(untested, key=lambda peer: abs(peer - target))[0]
    if best == node:
      if not path[:-1]:
         raise ValueError("Cannot find a route to the target in this network.")
      best = path[-2]
    return best
  
  def randomrouting(locs, start, target):
      path = [start]
      randomnet = {}
      for i in locs:
        peers = numpy.random.choice(locs, size=outdegree, replace=False)
        randomnet[i] = peers
      # show random net
      net = []
      for i in randomnet:
        net.append(randomnet[i])
      plotring(locs, net, "random net")
      # route on random net
      while path[-1] != target:
        node = path[-1]
        peers = randomnet[node]
        path.append(step(path, node, peers, target))
      plotring(locs, [path], "random path")
      return len(path)
  
  def smallworldrouting(locs, start, target):
      path = [start]
      # small world routing
      smallworldnet = {}
      sortedlocs = sorted(list(locs))
      lensortedlocs = len(sortedlocs)
      # know your neighbors
      linksperhop = max(1, outdegree//3)
      halfnumshortlinks = max(1, linksperhop/2)
      for n, i in enumerate(sortedlocs):
        smallworldnet[i] = []
        if n-halfnumshortlinks < 0:
          smallworldnet[i].extend(sortedlocs[n-halfnumshortlinks:])
        if n+halfnumshortlinks > lensortedlocs:
          smallworldnet[i].extend(sortedlocs[:(n+halfnumshortlinks)%lensortedlocs])
        smallworldnet[i] = sortedlocs[max(0, n-halfnumshortlinks):min(lensortedlocs, n+halfnumshortlinks)]
      numlonglinks = linksperhop
      for n, i in enumerate(sortedlocs):
        smallworldnet[i].extend(list(numpy.random.choice(sortedlocs, size=numlonglinks, replace=False)))
      # as many medium size links as left after substracting the long and short links
      nummediumlinks = outdegree-(linksperhop*2)
      maxmediumdistance = max(lensortedlocs/10, 4)
      for i in range(nummediumlinks):
        for n, i in enumerate(sortedlocs):
          down = numpy.random.choice(maxmediumdistance)
          up = numpy.random.choice(maxmediumdistance)
          lower = (n-down)%lensortedlocs
          upper = (n+up)%lensortedlocs
          smallworldnet[i].append(sortedlocs[lower])
          smallworldnet[i].append(sortedlocs[upper])
      # show small world net
      net = []
      for i in smallworldnet:
        net.append(smallworldnet[i])
      plotring(locs, net, "small world net")
      # route on small world net
      while path[-1] != target:
        node = path[-1]
        peers = smallworldnet[node]
        path.append(step(path, node, peers, target))
      plotring(locs, [path], "small world path")
      return len(path)
  
  randompaths = []
  smallworldpaths = []
  for i in range(2):
      target = numpy.random.choice(locs)
      start = numpy.random.choice(locs)
      randompaths.append(randomrouting(locs, start, target))
      smallworldpaths.append(smallworldrouting(locs, start, target))
  print "random:", randompaths
  print "small world:", smallworldpaths

#+END_SRC

#+RESULTS:
: random: [22, 19]
: small world: [13, 10]






