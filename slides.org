#+title: Freenet \\ \vspace{0.5cm} \scriptsize The technical part of the solution for freedom of the press in the internet
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: default
#+DATE: September 11, 2014
#+options: H:2
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %10BEAMER_envargs(Env Args) %4BEAMER_col(Col) %8BEAMER_extra(Extra)
#+PROPERTY: BEAMER_col_ALL 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.0 :ETC

* Why?

** Why Freenet?

#+BEGIN_QUOTE
I worry about my child and the Internet all the time, even though she' too young to have logged on yet. Here's what I worry about. I worry that 10 or 15 years from now, she will come to me and say 'Daddy, where were you when they took freedom of the press away from the Internet?'
--Mike Godwin, Electronic Frontier Foundation, [[https://w2.eff.org/Misc/EFF/quotes.eff.txt][“Fear of Freedom” (1995)]]
#+END_QUOTE

** Why now?

#+BEGIN_QUOTE
“There is now no shield from forced exposure…The foundation of Groklaw is over…the Internet is over” --Groklaw, [[http://www.groklaw.net/article.php?story=20130818120421175][Forced Exposure (2013-08-20)]]
#+END_QUOTE

* About
** What is Freenet?

#+BEGIN_QUOTE
Freenet is the technical part of the solution for freedom of the press in the internet.
#+END_QUOTE

** THE technical part? Other projects
***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
****                                                                  :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :END:


***** Pure Transport                                     :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. tor, i2p/

- No offline hosting
- vulnerable to DoS
- correlation attacks

#+latex: \small
/this killed the Black Goblin Market/

***** Hosting with cost                                             :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. TAHOE-LAFS, MaidSafe/

- Fixed storage: When it is full, it is full
- DoS-resistance? Spam-resistance? Cost?

/Good content often comes from small publishers./

****                                                                  :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :END:

***** Pure messaging                                                :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. bitmessage, invisible.im/

- No publishing
- No offline hosting

***** Server-based                                                  :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

/e.g. SecureDrop/

- Requires powerful infrastructure 
- DoS-able
- Timing attacks (correlation)

***** GNUnet?                                                       :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

Good, but more filesharing than publishing.

** THE technical part? Freenet

***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
**** Communication                                            :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *persistent pseudonyms*
- *spam resistance* via WoT
- *multiple applications* (Sone, FMS, Freemail, FlogHelper, ...)

**** Publishing                                               :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *offline hosting* \\ Join, drop content, leave.
- *decaying storage* \\ lifetime depends on user demand

***                                                                 :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:

Proven track record of providing censorship resistant publishing and communication since 2000.

** The TECHNICAL part?
***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
**** Tech alone is not enough                                 :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

Complete blocking and surveillance is possible.

**** Politics alone is not enough                             :B_block:BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :BEAMER_env: block
     :END:

If surveillance and censorship is trivial, it will be done.

*** Tech and Politics                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:

Privacy technology provides the background on which politics can work: Making surveillance and censorship expensive and hard enough that we can win the political battle.

** Who are we?

***                                                           :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.6
    :END:

- 2 paid part time developers: \\ toad and xor.
- About a dozen free-time developers.
- Some anonymous contributors.
- Communication mostly over IRC (=#freenet @ irc.freenode.net=) and FMS
  (in Freenet).

***                                                           :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.35
    :END:

#+caption: Some Freenet developers at CTS4. From left to right: ArneBab, toad, leuchtkaefer and digger3.
[[file:freenet-cts4-20130930_135137.jpg]]


* Applications
** TODO File Hosting

# Left: Upload a file: Key-selection, File-selection

# Right: Upload Queue, Download Queue

# decentralized pastebin

** TODO Darknet Messaging

# Confidential messaging friend-to-friend

# with file hosting: confidential pastebin

** TODO Websites

# nerdageddon

# we call them freesites

** TODO Site creation

# Howto-screenshot + jSite + freesitemgr

** TODO Blogging

# Flog helper, Sitelink

** TODO Spam resistance

# WoT: List of IDs

** TODO μBlogging

# Sone

** TODO Forums

# FMS

** TODO Why not as big as tor?

# Focus (rabbit defocussed)

# Money
* Funding
** TODO Goal

# Journalist + Whistleblower

** TODO What we need

# 2-8 people, 3-5 years

# Minimal, Good, Ideal

** TODO 2 year vision

** Going further

***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
**** publication and collaboration:          :B_block:BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :BEAMER_env: block
     :END:

   - platform for political bloggers
   - social network with privacy by design
   - programming platform

**** backend for the web:                                     :B_block:BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.45
     :BEAMER_env: block
     :END:

   - comment system for websites
   - exchanging files with friends

*** harder to detect and block:                                     :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:

  - hide data in VoIP stream
  - hiding data in email attachments
  - pre-filled USB-sticks to exchange with collegues and friends
  - … and many more - see Steganography

** TODO What is in it for me?

# If it’s safe enough for whistleblowers, it’s safe enough to give you privacy.

# The more people use Freenet, the safer it gets (plausible deniability + hide in the forest).

* Tech

** About the tech
***                                                               :B_columns:
    :PROPERTIES:
    :BEAMER_env: columns
    :END:
**** Datastore                                                :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *decentralized* \\ on the computers of users
- *encrypted chunks of files* \\ key (URL) to assemble, decrypt and identify
- *anonymous pseudonyms* \\ public/private key publishing

**** Routing                                                  :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

- *small world*: scale free
- *optional friend-to-friend* (Darknet)
- *location*: [0..1) for each file chunk and node
- *find route*: from node to file chunk
- *forward data*: travels along the route

*** Applications                                                    :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:

- *subscribe to keys*: 30s to 30 min round trip time.
- *base for applications*: Websites, Forums, Microblogging, Chat.
- *spam resistance*: Web of Trust (2 implementations).

** Routing

***                                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.62
    :END:

#+caption: Finding the route to a chunk of data.
[[./freenet-routing.png]]

** Network structure

*** Opennet                                                   :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.45
    :END:

- *Optimize peer-connections* \\ via success-metric
- *Distance Constraint* \\ maximum number of long connections

*** Darknet (friend-to-friend)                                :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.45
    :END:

- *Assume small world* \\ connections to people known in real life
- *Reconstruct* \\ the structure by swapping locations

** Measured Network Structure

#+caption: Link length distribution in Freenet. The green line would be an ideal network. Blue would be a random network. Red is the measured distribution. Randomization from local requests, churn and inhomogenity in the network skew the distribution.
[[./607-plot_link_length.png]]


** Routing Simulation

#+BEGIN_SRC python :tangle routingsim.py :exports none :results output
  import numpy
  import math
  size = 1000
  locs = numpy.random.random(size)
  outdegree = int(math.log(size, 2))
  backoffprobability = 0.0


  def plotlinklengths(nets, title, filepath=None):
    import pylab
    pylab.clf()
    for net in nets:
        lengths = []
        for node in net:
          for link in net[node]:
            lengths.append(min(abs(link - node), abs(link - node - 1), abs(link - node + 1)))
        pylab.plot(sorted(lengths), numpy.arange(len(lengths))/float(len(lengths)))
    pylab.xscale("log")
    pylab.xlabel("link length")
    pylab.ylabel("fraction of links with this length or less")
    pylab.title(title)
    pylab.xlim(1./(size**2), 0.5)
    if filepath:
      pylab.savefig(filepath)
    else:
      pylab.show()


  def plotring(locs, paths, title, filepath=None):
    import pylab, numpy
    pylab.clf()
    ringx = numpy.sin(locs*math.pi*2)
    ringy = numpy.cos(locs*math.pi*2)
    pylab.scatter(ringx, ringy)# , color=matplotlib.cm.spectral(locs))
    for path in paths:
        path = numpy.array(path)
        pathx = numpy.sin(path*math.pi*2)
        pathy = numpy.cos(path*math.pi*2)
        for n,x in enumerate(pathx):
          try:
            xp1 = pathx[n+1]
            y = pathy[n]
            yp1 = pathy[n+1]
            # color = matplotlib.cm.spectral(locs[n])
          except:
            break
          # pylab.plot([x, xp1], [y, yp1])# , color=color)
        pylab.plot(pathx, pathy)# , color=color)
    pylab.title(title)
    if filepath:
      pylab.savefig(filepath)
    else:
      pylab.show()


  def step(path, node, peers, target):
    # depth first traversal
    p = set(path)
    untested = [peer for peer in list(peers)
                if not peer in p 
                and numpy.random.random() > backoffprobability]
    if not untested:
      if not path[:-1]:
         raise ValueError("No nodes to test and cannot step back: Cannot find a route to the target in this network.")
      # step back
      return path[-2]
    best = sorted(untested, key=lambda peer: abs(peer - target))[0]
    if best == node:
      if not path[:-1]:
         raise ValueError("Cannot find a route to the target in this network.")
      best = path[-2]
    return best


  def randomrouting(locs, start, target, filepath=None):
      path = [start]
      randomnet = {}
      for i in locs:
        peers = numpy.random.choice(locs, size=outdegree, replace=False)
        randomnet[i] = peers
      # show random net
      links = []
      for i in randomnet:
        links.append(randomnet[i])
      # route on random net
      while path[-1] != target:
        node = path[-1]
        peers = randomnet[node]
        path.append(step(path, node, peers, target))
      return randomnet, path


  def smallworldrouting(locs, start, target, filepath=None):
      path = [start]
      # small world routing
      smallworldnet = {}
      sortedlocs = sorted(list(locs))
      lensortedlocs = len(sortedlocs)
      linksperhop = max(1, outdegree//3)
      for i in sortedlocs:
          smallworldnet[i] = []
      # know your neighbors
      halfnumshortlinks = max(1, linksperhop/2) + 1
      maxshortdistance = outdegree/2
      for dist in range(halfnumshortlinks):
        for n, i in enumerate(sortedlocs):
          down = min(numpy.random.choice(maxshortdistance, 3)) + 1
          up = min(numpy.random.choice(maxshortdistance, 3)) + 1
          lower = sortedlocs[(n-down)%lensortedlocs]
          while lower in smallworldnet[i]:
              down += 1
              lower = sortedlocs[(n-down)%lensortedlocs]
          upper = sortedlocs[(n+up)%lensortedlocs]
          while upper in smallworldnet[i]:
              up += 1
              upper = sortedlocs[(n+up)%lensortedlocs]
          smallworldnet[i].append(lower)
          smallworldnet[i].append(upper)
      # long connections
      numlonglinks = linksperhop
      for n, i in enumerate(sortedlocs):
        smallworldnet[i].extend(list(numpy.random.choice(sortedlocs, size=numlonglinks, replace=False)))
      # as many medium size links as left after substracting the long and short links
      nummediumlinks = outdegree - (halfnumshortlinks*2) - numlonglinks
      maxmediumdistance = max(lensortedlocs/(outdegree*2), outdegree)
      for i in range(nummediumlinks):
        for n, i in enumerate(sortedlocs):
          down = numpy.random.choice(maxmediumdistance) + 1
          up = numpy.random.choice(maxmediumdistance) + 1
          lower = (n-down)%lensortedlocs
          while lower in smallworldnet[i]:
              down += 1
              lower = sortedlocs[(n-down)%lensortedlocs]
          upper = (n+up)%lensortedlocs
          while upper in smallworldnet[i]:
              up += 1
              upper = sortedlocs[(n+up)%lensortedlocs]
          smallworldnet[i].append(sortedlocs[lower])
          smallworldnet[i].append(sortedlocs[upper])
      # show small world net
      links = []
      for i in smallworldnet:
        links.append(smallworldnet[i])
      # route on small world net
      while path[-1] != target:
        node = path[-1]
        peers = smallworldnet[node]
        path.append(step(path, node, peers, target))
      return smallworldnet, path

  randompaths = []
  smallworldpaths = []
  randomnets = []
  smallworldnets = []
  for i in range(10):
      target = numpy.random.choice(locs)
      start = numpy.random.choice(locs)
      randomnet, randompath = randomrouting(locs, start, target)
      smallworldnet, smallworldpath = smallworldrouting(locs, start, target)
      randompaths.append(randompath)
      smallworldpaths.append(smallworldpath)
      randomnets.append(randomnet)
      smallworldnets.append(smallworldnet)

  randompathlens = [len(p) for p in randompaths]
  smallworldpathlens = [len(p) for p in smallworldpaths]

  plotlinklengths(randomnets+smallworldnets, "Link lengths", 
           filepath="size-{}-peers-{}-backoffpercentage-{:03}-hash-{}-linklengths.png".format(
             len(locs), outdegree, int(100*backoffprobability), hash(tuple(locs))))
  plotring(locs, randompaths, "random paths", 
           filepath="size-{}-peers-{}-backoffpercentage-{:03}-hash-{}-meanlen-{}-random.png".format(
             len(locs), outdegree, int(100*backoffprobability), hash(tuple(locs)), int(numpy.mean(randompathlens))))
  plotring(locs, smallworldpaths, "small world paths", 
           filepath="size-{}-peers-{}-backoffpercentage-{:03}-hash-{}-meanlen-{}-smallworld.png".format(
             len(locs), outdegree, int(100*backoffprobability), hash(tuple(locs)), int(numpy.mean(smallworldpathlens))))
  print "random:", randompathlens
  print "small world:", smallworldpathlens

#+END_SRC

#+RESULTS:
: random: [60, 6, 70, 9, 313, 22, 79, 5, 170, 204]
: small world: [9, 7, 8, 6, 6, 7, 7, 5, 5, 5]


*** Random routing                                            :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:

#+caption: 10 paths between locations on a random network. Average path length: 143.
[[./size-1000-hash-5713902561315010956-meanlen-143-random.png]]

*** Small world routing                                       :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.45
    :END:

#+caption: 10 paths between locations on a small world network. Average path length: 15.
[[./size-1000-hash-5713902561315010956-meanlen-15-smallworld.png]]

#+RESULTS:
: random: [203, 151, 50, 84, 27, 169, 258, 265, 18, 232]
: small world: [5, 3, 6, 9, 4, 11, 7, 8, 5, 4]

** Link length of the Simulations

